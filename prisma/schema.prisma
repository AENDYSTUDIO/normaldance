// Simplified Prisma schema for NORMAL DANCE - SQLite compatible
// For quick production start with 0 users

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User model for artists and listeners
model User {
  id            String   @id @default(cuid())
  email         String?  @unique
  username      String   @unique
  displayName   String
  bio           String?
  avatar        String?
  banner        String?
  walletAddress String?  @unique // Web3 wallet address
  level       String   @default("BRONZE") // UserLevel as string
  balance     Float    @default(0) // $NDT token balance
  tonBalance  Float    @default(0) // TON balance
  isArtist    Boolean  @default(false)
  isActive    Boolean  @default(true)
  role        String   @default("LISTENER") // UserRole as string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Индексы для оптимизации запросов
  @@index([username])
  @@index([walletAddress])
  @@index([isArtist])
  @@index([level])
  @@index([createdAt])
  @@index([isActive])
  
  // Relations
  tracks        Track[]
  playlists     Playlist[]
  likes         Like[]
  comments      Comment[]
  rewards       Reward[]
  follows       Follow[]    @relation("UserFollowing")
  followedBy    Follow[]    @relation("UserFollowers")
  playHistory   PlayHistory[]
  nfts          NFT[]
  purchases     Purchase[]
  stakes        Stake[]
  sentDonations Donation[]  @relation("DonationSender")
  receivedDonations Donation[] @relation("DonationReceiver")
  
  @@map("users")
}

// Track model for music files
model Track {
  id          String   @id @default(cuid())
  title       String
  artist      String   // Artist name as string
  genre       String
  duration    Int      // Duration in seconds
  description String?
  playCount   Int      @default(0)
  likeCount   Int      @default(0)
  ipfsHash    String   // IPFS hash for audio file
  fileSize    Int      // File size in bytes
  mimeType    String   // MIME type
  price       Float?   // Price in $NDT (null = free)
  isExplicit  Boolean  @default(false)
  isPublished Boolean  @default(false)
  status      String   @default("DRAFT") // TrackStatus as string
  releaseDate DateTime
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Индексы для оптимизации запросов
  @@index([userId])
  @@index([genre])
  @@index([isPublished])
  @@index([status])
  @@index([playCount])
  @@index([likeCount])
  @@index([createdAt])
  @@index([releaseDate])
  @@index([artist])
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  likes       Like[]
  comments    Comment[]
  playlistTracks PlaylistTrack[]
  playHistory PlayHistory[]
  nfts        NFT[]
  
  @@map("tracks")
}

// Playlist model for user playlists
model Playlist {
  id          String   @id @default(cuid())
  name        String
  description String?
  isPublic    Boolean  @default(true)
  coverImage  String?
  playCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  tracks      PlaylistTrack[]
  
  @@map("playlists")
}

// Junction table for many-to-many relationship between playlists and tracks
model PlaylistTrack {
  id        String @id @default(cuid())
  position  Int    // Order in playlist
  
  playlistId String
  playlist  Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  
  trackId   String
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@unique([playlistId, trackId])
  @@map("playlist_tracks")
}

// Like model for track likes
model Like {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  // Индексы для оптимизации
  @@index([userId])
  @@index([trackId])
  @@index([createdAt])
  @@unique([userId, trackId])
  @@map("likes")
}

// Comment model for track comments
model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@map("comments")
}

// Reward model for user rewards and earnings
model Reward {
  id        String   @id @default(cuid())
  type      String   // RewardType as string
  amount    Float    // Amount as float instead of Decimal
  reason    String?
  createdAt DateTime @default(now())
  
  // Relations
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("rewards")
}

// Follow model for user relationships
model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  // Relations
  followerId  String
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  
  followingId String
  following   User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
  @@map("follows")
}

// Play history model for tracking user listens
model PlayHistory {
  id          String   @id @default(cuid())
  duration    Int      // Listen duration in seconds
  completed   Boolean  @default(false) // Did user finish the track?
  createdAt   DateTime @default(now())
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@map("play_history")
}

// NFT model for music NFTs
model NFT {
  id          String   @id @default(cuid())
  tokenId     String   @unique // Solana token ID
  name        String
  description String?
  imageUrl    String?
  metadata    String?  // JSON as string
  price       Float?   // Price as float instead of Decimal
  status      String   @default("MINTED") // NFTStatus as string
  type        String   @default("TRACK") // NFTType as string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  ownerId     String
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  
  trackId     String?
  track       Track?   @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  purchases   Purchase[]
  
  @@map("nfts")
}

// Purchase model for NFT purchases
model Purchase {
  id          String   @id @default(cuid())
  price       Float    // Purchase price as float
  transaction String   // Blockchain transaction hash
  createdAt   DateTime @default(now())
  
  // Relations
  buyerId String
  buyer   User     @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  
  nftId   String
  nft     NFT      @relation(fields: [nftId], references: [id], onDelete: Cascade)
  
  @@unique([buyerId, nftId])
  @@map("purchases")
}

// Stake model for token staking
model Stake {
  id          String   @id @default(cuid())
  amount      Float    // Amount as float instead of Decimal
  rewardRate  Float    // Annual percentage rate (APR)
  earned      Float    @default(0) // Earned rewards as float
  status      String   @default("ACTIVE") // StakeStatus as string
  startDate   DateTime @default(now())
  endDate     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userId String
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("stakes")
}

// Donation model for user donations
model Donation {
  id        String   @id @default(cuid())
  amount    Float
  message   String?
  signature String   @unique
  status    String   @default("pending")
  createdAt DateTime @default(now())

  // Relations
  fromUserId String
  fromUser   User   @relation("DonationSender", fields: [fromUserId], references: [id], onDelete: Cascade)

  toUserId   String
  toUser     User   @relation("DonationReceiver", fields: [toUserId], references: [id], onDelete: Cascade)

  @@map("donations")
}