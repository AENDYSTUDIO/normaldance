// Simplified Prisma schema for NORMAL DANCE - SQLite compatible
// For quick production start with 0 users

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model for artists and listeners
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  username    String   @unique
  displayName String?
  bio         String?
  avatar      String?
  banner      String?
  wallet      String?  // Web3 wallet address
  level       String   @default("BRONZE") // UserLevel as string
  balance     Float    @default(0) // $NDT token balance
  tonBalance  Float    @default(0) // TON balance
  isArtist    Boolean  @default(false)
  isActive    Boolean  @default(true)
  role        String   @default("LISTENER") // UserRole as string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tracks      Track[]
  playlists   Playlist[]
  likes       Like[]
  comments    Comment[]
  rewards     Reward[]
  follows     Follow[]    @relation("UserFollowing")
  followedBy  Follow[]    @relation("UserFollowers")
  playHistory PlayHistory[]
  nfts        NFT[]
  purchases   Purchase[]
  stakes      Stake[]
  
  @@map("users")
}

// Track model for music files
model Track {
  id          String   @id @default(cuid())
  title       String
  artistName  String   // Artist name as string
  genre       String
  duration    Int      // Duration in seconds
  playCount   Int      @default(0)
  likeCount   Int      @default(0)
  ipfsHash    String   // IPFS hash for audio file
  metadata    String?  // JSON as string
  price       Float?   // Price in $NDT (null = free)
  isExplicit  Boolean  @default(false)
  isPublished Boolean  @default(false)
  status      String   @default("DRAFT") // TrackStatus as string
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  artistId    String
  artist      User     @relation(fields: [artistId], references: [id], onDelete: Cascade)
  
  likes       Like[]
  comments    Comment[]
  playlistTracks PlaylistTrack[]
  playHistory PlayHistory[]
  nfts        NFT[]
  
  @@map("tracks")
}

// Playlist model for user playlists
model Playlist {
  id          String   @id @default(cuid())
  name        String
  description String?
  isPublic    Boolean  @default(true)
  coverImage  String?
  playCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  tracks      PlaylistTrack[]
  
  @@map("playlists")
}

// Junction table for many-to-many relationship between playlists and tracks
model PlaylistTrack {
  id        String @id @default(cuid())
  position  Int    // Order in playlist
  
  playlistId String
  playlist  Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  
  trackId   String
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@unique([playlistId, trackId])
  @@map("playlist_tracks")
}

// Like model for track likes
model Like {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@unique([userId, trackId])
  @@map("likes")
}

// Comment model for track comments
model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@map("comments")
}

// Reward model for user rewards and earnings
model Reward {
  id        String   @id @default(cuid())
  type      String   // RewardType as string
  amount    Float    // Amount as float instead of Decimal
  reason    String?
  createdAt DateTime @default(now())
  
  // Relations
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("rewards")
}

// Follow model for user relationships
model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  // Relations
  followerId  String
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  
  followingId String
  following   User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
  @@map("follows")
}

// Play history model for tracking user listens
model PlayHistory {
  id          String   @id @default(cuid())
  duration    Int      // Listen duration in seconds
  completed   Boolean  @default(false) // Did user finish the track?
  createdAt   DateTime @default(now())
  
  // Relations
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  trackId String
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  @@map("play_history")
}

// NFT model for music NFTs
model NFT {
  id          String   @id @default(cuid())
  tokenId     String   @unique // Solana token ID
  name        String
  description String?
  imageUrl    String?
  metadata    String?  // JSON as string
  price       Float?   // Price as float instead of Decimal
  status      String   @default("MINTED") // NFTStatus as string
  type        String   @default("TRACK") // NFTType as string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  ownerId     String
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  
  trackId     String?
  track       Track?   @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  purchases   Purchase[]
  
  @@map("nfts")
}

// Purchase model for NFT purchases
model Purchase {
  id          String   @id @default(cuid())
  price       Float    // Purchase price as float
  transaction String   // Blockchain transaction hash
  createdAt   DateTime @default(now())
  
  // Relations
  buyerId String
  buyer   User     @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  
  nftId   String
  nft     NFT      @relation(fields: [nftId], references: [id], onDelete: Cascade)
  
  @@unique([buyerId, nftId])
  @@map("purchases")
}

// Stake model for token staking
model Stake {
  id          String   @id @default(cuid())
  amount      Float    // Amount as float instead of Decimal
  rewardRate  Float    // Annual percentage rate (APR)
  earned      Float    @default(0) // Earned rewards as float
  status      String   @default("ACTIVE") // StakeStatus as string
  startDate   DateTime @default(now())
  endDate     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userId String
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("stakes")
}
